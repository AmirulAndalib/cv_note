> 首先阅读文本几乎不需要深度学习算法基础，仅仅需要一点 Python 编程基础。

- [前言](#前言)
- [一，OpenCV 和 MediaPipe 介绍](#一opencv-和-mediapipe-介绍)
  - [1.1，OpenCV 介绍](#11opencv-介绍)
  - [1.2，OpenCV-Python 安装](#12opencv-python-安装)
    - [1.2.1，预构建的二进制文件安装 OpenCV-Python](#121预构建的二进制文件安装-opencv-python)
  - [1.3，MediaPipe 介绍](#13mediapipe-介绍)
  - [1.4，MediaPipe 安装](#14mediapipe-安装)
- [二，OpenCV 趣味项目](#二opencv-趣味项目)
  - [2.1，OpenCV 实现人脸检测](#21opencv-实现人脸检测)
  - [2.2，OpenCV 实现抖音晃眼睛特效](#22opencv-实现抖音晃眼睛特效)
  - [2.3，OpenCV 给人脸加上 1024 庆祝 LOGO](#23opencv-给人脸加上-1024-庆祝-logo)
  - [2.4 OpenCV 实现人脸检测+抖音晃眼睛特效+给头顶加上1024庆祝LOGO](#24-opencv-实现人脸检测抖音晃眼睛特效给头顶加上1024庆祝logo)
- [三，MediaPipe 趣味项目](#三mediapipe-趣味项目)
- [参考资料](#参考资料)

## 前言

## 一，OpenCV 和 MediaPipe 介绍

### 1.1，OpenCV 介绍

`OpenCV` 的全称 是 `Open Source Computer Vision Library`，是一个跨平台的计算机视觉库。`OpenCV` 是由英特尔公司发起并参与开发，以 `BSD` 许可证授权发行，可以在商业和研究领域中免费使用。OpenCV 可用于开发实时的图像处理、计算机视觉以及模式识别程序。

`OpenCV` 库用 `C++` 语言编写，它的主要接口也是 `C++` 语言，同时所有新的算法也是用 `C++` 编写，同时也提供了大量的 `Python`, `Java` 和 `MATLAB` 接口。`OpenCV` 可以在 `Windows`, `Android`, `iOS`, `Linux` 和 `Mac OS` 等平台上运行，其可以使用 `CMake` 编译。
> 来源[维基百科](https://zh.m.wikipedia.org/zh-hans/OpenCV)

`OpenCV` 目前的最新版本是 `4.6.0`，可通过[在线文档](https://docs.opencv.org/)获取 API 接口函数的文档。虽然从 3.0 版本以来，`OpenCV` 也提供了 `DNN`（深度神经网络）模块，但是在实际项目当中，开发者还是只利用了 `OpenCV` 读取、和保存图像/视频的功能，以及传统图像处理的一些算法功能等。

### 1.2，OpenCV-Python 安装

**推荐安装环境**: Ubuntu16.04 以上 + Python3.6 以上 + pip 库。

本文只介绍 OpenCV-Python 接口库的安装，本身的安装较为复杂，需要下载源代码和使用 CMake 编译安装，本文不做描述。
> Python 和 C++ 的 OpenCV 接口几乎一样，不同的是使用用 C++ 版本，矩阵用的是 cv::Mat，Python 版本矩阵用的是 numpy.array，大部分接口的用法相似。

`OpenCV-Python` 可以通过两种方式安装在 Ubuntu 系统中： 
- 从 Ubuntu 存储库中可用的预构建二进制文件安装，或者使用 `pip` 直接安装。
- 从源代码编译

#### 1.2.1，预构建的二进制文件安装 OpenCV-Python

1，对于 `Ubuntu` 系统，可通过以下命令行方式安装二进制文件包。
```bash
sudo apt-get update
sudo apt-get install python-opencv
```
> apt-get update 只是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。update只是更新了 apt 的**资源列表**，没有真正的对系统执行更新。如果需要系统软件，要使用 `apt-get upgrade` 来更新。

![apt-get方式安装python-opencv](./images/apt-get_install_python-opencv.png)

2，对于 `Windows/Ubuntu/Mac OS` 系统，如果系统本身已经安装了 `Python` 解释器和 `pip` 工具，则可直接通过 `pip` 工具安装：
```bash
pip install opencv-python
```

在终端中通过进入 `python` 解释器运行环境，输入以下代码检查 `opencv-python` 包是否成功安装，或者通过 `pip list` 命令查看已安装的 python 包是否有 `opencv-python` 包。

```python
>>> import cv2
>>> print( cv2.__version__ )
4.6.0
```
### 1.3，MediaPipe 介绍

`MediaPipe` 是一个为直播和流媒体提供跨平台、可定制的机器学习解决方案的框架，具有如下优点:
- 端到端加速
- 一次构建，随处部署
- 开箱即用的解决方案
- 免费且开源

![MediaPipe 流媒体视频管线框架优点](./images/mediapipe_advantage.png)

`MediaPipe` 提供了包括**人脸检测、人脸网格、虹膜识别、手部关键点检测、人体姿态估计、人体+人脸+手部组合整体、头发分割、目标检测、Box 跟踪、即时运动追踪、3D 目标检测等**解决方案。

![MediaPipe框架的机器学习解决方案](./images/ml_solutions_in_MediaPipe.png)

MediaPipe 对移动端 Android/iOS 系统和 C++/Python/JS 编程语言的各个接口支持情况如下表所示:

![各个接口支持情况](./images/interface_support_list.png)

`MediaPipe Python` 框架允许直接访问 `MediaPipe C++` 框架的核心组件： `Timestamp`、`Packet` 和 `CalculatorGraph`。`MediaPipe` 框架通过 [pybind11](https://pybind11.readthedocs.io/en/stable/index.html)提供 `Python` 接口。

### 1.4，MediaPipe 安装

`MediaPipe` 以预构建二进制文件的形式提供开箱即用且可定制化修改的 Python 解决方案。MediaPipe Python 包可用于 `Linux`、`macOS` 和 `Windows` 的 `PyPI`。

`MediaPipe Python` 包的安装命令如下: 

```bash
pip install mediapipe
```

`MediaPipe` 从源码到编译安装方式可参考[Installation](https://google.github.io/mediapipe/getting_started/install.html)。

## 二，OpenCV 趣味项目

借助 `OpenCV` 库实现人脸检测 + 抖音特效 + `1024` 程序员节 `LOGO`。

### 2.1，OpenCV 实现人脸检测

本文使用基于 Haar 特征的级联分类器实现对人脸框的检测。
> 级联分类器原理的解释参考 [使用 Haar Cascades 进行人脸检测](https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0)

首先，我们加载所需的人脸预训练分类器 XML 文件，然后以灰度模式加载我们的输入图像。

然后我们可以通过分类器找到人脸，并将人脸的位置返回为 `Rect` `(x,y,w,h)`。得到人脸框的位置后，就可以通过 `OpenCV` 的画矩形函数 `cv2.rectangle` 画人脸框。

`OpenCV` 实现人脸检测的 `Python` 代码如下:

```python
import cv2

# Load the cascade
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

if __name__ == "__main__":
    img = cv2.imread("./images/student.png") # 必须为 png 图片

    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Convert to grayscale
    # 第二个参数值越大能检测出的人脸越多，但是有可能误检
    faces = face_cascade.detectMultiScale(gray, 1.2, 4) # Detect the faces
    
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2) # drae red face detect bbox
    cv2.imwrite('./images/face_detect.png', img)
```

运行以上 `Python` 代码后的效果如下所示:

![opencv实现人脸检测效果](./images/face_detect.png)

### 2.2，OpenCV 实现抖音晃眼睛特效

抖音 logo 的图片如下所示。

![抖音logo](./images/douyin_logo.jpeg)

抖音 `logo` 的晃眼睛特效原理是基于原图生成一张 R 通道和 GB 通道的图像，互相之间略微错位下，然后生成两个三维矩阵，最后将这两个矩阵相加即可得到晃眼睛特效。
> 注意两个图像相加，要求两个图像应该具有相同的大小和类型，或者第二个图像可以是标量值。

晃眼睛特效的具体 `Python` 代码如下：
```python
import cv2
import copy
from PIL import Image
import numpy as np

def douyin_effect(img):
    # face= image[y: y+h, x: x+w] # create a ROI for the face
    img_rgba = cv2.cvtColor(img, cv2.COLOR_BGR2RGBA)
    
    # 通过把gb通道值置为0，生成r通道的图片
    image_arr_r = copy.deepcopy(img_rgba)
    image_arr_r[:, :, 1:3] = 0
    image_r = Image.fromarray(image_arr_r).convert('RGBA')
    # 通过把r通道值置为0，生成gb通道的图片
    image_arr_gb = copy.deepcopy(img_rgba)
    image_arr_gb[:, :, 0] = 0
    image_gb = Image.fromarray(image_arr_gb).convert('RGBA')
    
    # 生成一张黑色背景的画布图片，并把r通道图片复制粘贴在上面，粘贴的位置为(10,10)是为了与后面的gb通道图片错开
    # 第二个参数值越大，错位效果越明显越晃眼睛
    canvas_r = Image.new('RGB', (img.shape[1], img.shape[0]), color=(0, 0, 0))
    canvas_r.paste(image_r, (10, 10), image_r)
    # gb通道图片的处理与上面类似
    canvas_gb = Image.new('RGB', (img.shape[1], img.shape[0]), color=(0, 0, 0))    
    canvas_gb.paste(image_gb, (0, 0), image_gb)
    
    add_image = np.array(canvas_gb) + np.array(canvas_r)
    output_image = cv2.cvtColor(add_image, cv2.COLOR_RGB2BGR)
    
    return output_image

if __name__ == "__main__":
    img = cv2.imread("./images/dog.png") # 必须为 png 图片
    output_image = douyin_effect(img)
    cv2.imwrite('./images/douyin_effect.png', output_image)
```

程序运行后的输出结果和原图对比图如下所示:

![对比图](./images/douyin_effect.png)

### 2.3，OpenCV 给人脸加上 1024 庆祝 LOGO

给头顶加上 1024 庆祝 LOGO 的原理其实等同于给头顶加上帽子的原理。因为涉及到这里 LOGO 图像和人脸图像的融合所以 LOGO 图像必须是 4 通道的。

Python 实现代码如下:
```python
import cv2
import copy
from PIL import Image
import numpy as np

# Load the cascade
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
hat_img_bgra = cv2.imread("./images/1024.png", -1) # 图像需为PNG格式（方便alpha通道的使用）
r, g, b, a = cv2.split(hat_img_bgra)
hat_rgb = cv2.merge((r, g, b)) # 把 rgb 三通道合成一张rgb的彩色图, shape is (height, width, channel)

def code_holiday_celebration(image, x, y, w, h, center):
    # 根据人脸大小调整节日 logo 大小(公式随意，比例一致即可)
    # ***********************************************************
    factor = 1.0 # 可调
    # ***********************************************************
    scaled_factor = w/hat_rgb.shape[1] # 缩放比例计算
    # 根据人脸大小缩放后的节日 logo 尺寸
    resized_hat_h = int(round(hat_rgb.shape[0] * scaled_factor * factor))
    resized_hat_w = int(round(hat_rgb.shape[1] * scaled_factor * factor))
    if resized_hat_h > y:
        resized_hat_h = y-1		#可调
    
    hat_resized = cv2.resize(hat_rgb, (resized_hat_w, resized_hat_h))
    
    mask = cv2.resize(a, (resized_hat_w, resized_hat_h))
    mask_inv = cv2.bitwise_not(mask)
 
    # LOGO 相对于人脸框上线的偏移量
    # ***********************************************************
    dh = 0			# 可调
    dw = -10		# 可调
    # ***********************************************************
    # 原图 ROI(这个公式原则上也可调)
    bg_roi = image[y + dh - resized_hat_h : y + dh, 
                  (center + dw - resized_hat_w//3):(center + dw + resized_hat_w//3*2)]
    # 原图 ROI 中提取放 LOGO 的区域
    bg_roi = bg_roi.astype(float)
    mask_inv = cv2.merge((mask_inv, mask_inv, mask_inv))
    alpha = mask_inv.astype(float)/255
    # 相乘之前保证两者大小一致（可能会由于四舍五入原因不一致）
    alpha = cv2.resize(alpha, (bg_roi.shape[1], bg_roi.shape[0]))
    bg = cv2.multiply(alpha, bg_roi)
    bg = bg.astype('uint8')

    # 提取帽子区域
    hat = cv2.bitwise_and(hat_resized, hat_resized, mask=mask)
    # 添加圣诞帽
    hat = cv2.resize(hat, (bg_roi.shape[1], bg_roi.shape[0]))
    
    # 两个ROI区域相加
    add_hat = cv2.add(bg, hat)
    # 把添加好帽子的区域放回原图
    image[y + dh - resized_hat_h: y + dh, (center + dw - resized_hat_w//3):(center + dw + resized_hat_w//3*2)] = add_hat
    return image

if __name__ == "__main__":
    img = cv2.imread("./images/programmer.png") # 必须为 png 图片
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Convert to grayscale
    faces = face_cascade.detectMultiScale(gray, 1.4, 5) # Detect the faces
    
    for (x, y, w, h) in faces:
        roi_gray = gray[y: y+h, x: x+w]
        center = int(x + w/2)
        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2) # visual face detect bbox
        output_image = code_holiday_celebration(img, x, y, w, h, center)
    
    cv2.imwrite('./images/hat_on_head.png', output_image)
```

程序运行后的效果如下所示:

![效果对比图](./images/hat_on_head.png)

### 2.4 OpenCV 实现人脸检测+抖音晃眼睛特效+给头顶加上1024庆祝LOGO

本汇总代码不再是对图片流进行检测，而是对实时视频流进行动态监测，完整代码如下所示:

```python
"""
Reference:

"""

import cv2
import copy
from PIL import Image
import numpy as np

# Load the cascade
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
# To capture video from webcam. 
cap = cv2.VideoCapture(0) # opencv 的函数，参数 0 代表调用电脑自带摄像，若改为 1 则调用外设摄像
hat_img_bgra = cv2.imread("./images/1024.png", -1) # 图像需为PNG格式（方便alpha通道的使用）
r, g, b, a = cv2.split(hat_img_bgra)
hat_rgb = cv2.merge((r, g, b)) # 把 rgb 三通道合成一张rgb的彩色图, shape is (height, width, channel)

def douyin_effect(image, x, y, w, h):
    face_roi = image[y: y+h, x: x+w] # create a ROI for the face
    face_roi_rgba = cv2.cvtColor(face_roi, cv2.COLOR_BGR2RGBA)
    
    # 通过把gb通道值置为0，生成r通道的图片
    image_arr_r = copy.deepcopy(face_roi_rgba)
    image_arr_r[:, :, 1:3] = 0
    image_r = Image.fromarray(image_arr_r).convert('RGBA')
    # 通过把r通道值置为0，生成gb通道的图片
    image_arr_gb = copy.deepcopy(face_roi_rgba)
    image_arr_gb[:, :, 0] = 0
    image_gb = Image.fromarray(image_arr_gb).convert('RGBA')
    
    # 生成一张黑色背景的画布图片，并把r通道图片复制粘贴在上面，粘贴的位置为(10,10)是为了与后面的gb通道图片错开
    canvas_r = Image.new('RGB', (face_roi.shape[1], face_roi.shape[0]), color=(0, 0, 0))
    canvas_r.paste(image_r, (15, 15), image_r)
    # gb通道图片的处理与上面类似
    canvas_gb = Image.new('RGB', (face_roi.shape[1], face_roi.shape[0]), color=(0, 0, 0))    
    canvas_gb.paste(image_gb, (0, 0), image_gb)
    
    add_image = np.array(canvas_gb) + np.array(canvas_r)
    output_image = cv2.cvtColor(add_image, cv2.COLOR_RGB2BGR)
    
    return output_image

def code_holiday_celebration(image, x, y, w, h, eyes_center):
    # 根据人脸大小调整节日 logo 大小(公式随意，比例一致即可)
    # ***********************************************************
    factor = 1 # 可调
    # ***********************************************************
    scaled_factor = w/hat_rgb.shape[1] # 缩放比例计算
    # 根据人脸大小缩放后的节日 logo 尺寸
    resized_hat_h = int(round(hat_rgb.shape[0] * scaled_factor * factor))
    resized_hat_w = int(round(hat_rgb.shape[1] * scaled_factor * factor))
    if resized_hat_h > y:
        resized_hat_h = y-1		#可调
    
    hat_resized = cv2.resize(hat_rgb, (resized_hat_w, resized_hat_h))
    
    mask = cv2.resize(a, (resized_hat_w, resized_hat_h))
    mask_inv = cv2.bitwise_not(mask)
 
    # 帽子相对于人脸框上线的偏移量
    # ***********************************************************
    dh = 0			# 可调
    dw = -40		# 可调
    # ***********************************************************
    # 原图ROI(这个公式原则上也可调)
    # print(eyes_center + dw - resized_hat_w//3)
    # print(eyes_center + dw + resized_hat_w//3*2)
    bg_roi = image[y + dh - resized_hat_h : y + dh, 
                  (eyes_center + dw - resized_hat_w//3):(eyes_center + dw + resized_hat_w//3*2)]
    # 原图ROI中提取放帽子的区域
    bg_roi = bg_roi.astype(float)
    mask_inv = cv2.merge((mask_inv, mask_inv, mask_inv))
    alpha = mask_inv.astype(float)/255
    # 相乘之前保证两者大小一致（可能会由于四舍五入原因不一致）
    alpha = cv2.resize(alpha, (bg_roi.shape[1], bg_roi.shape[0]))
    bg = cv2.multiply(alpha, bg_roi)
    bg = bg.astype('uint8')

    # 提取帽子区域
    hat = cv2.bitwise_and(hat_resized, hat_resized, mask=mask)
    # 添加圣诞帽
    hat = cv2.resize(hat, (bg_roi.shape[1], bg_roi.shape[0]))
    
    # 两个ROI区域相加
    add_hat = cv2.add(bg, hat)
    # 把添加好帽子的区域放回原图
    image[y + dh - resized_hat_h: y + dh, (eyes_center + dw - resized_hat_w//3):(eyes_center + dw + resized_hat_w//3*2)] = add_hat
    return image

def sketch_image(img):
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img_gray = cv2.medianBlur(img_gray, 5)
    edges = cv2.Laplacian(img_gray, cv2.CV_8U, ksize=5)
    ret, threshold = cv2.threshold(edges, 145, 255, cv2.THRESH_BINARY_INV)
    return threshold

def face_post_process(image, x, y, w, h, eyes_center):
    """Draw the rectangle and produce douyin effect around each face"""
    # 1, douyin effect
    douyin_face_roi = douyin_effect(image, x, y, w, h)
    image[y: y+h, x: x+w] = douyin_face_roi # douyin effect on image's face roi
    
    cv2.rectangle(image, (x, y), (x+w, y+h), (0, 0, 255), 2) # visual face detect bbox
    # 2, 1024 programmer's Day Celebration
    code_holiday_image = code_holiday_celebration(image, x, y, w, h, eyes_center)
    # eyes = eye_cascade.detectMultiScale(gray[y: y+h, x: x+w])
    # 3, face carton effect
    # cartoonized_image = cartonize_image(code_holiday_image)
    
    return code_holiday_image

if __name__ == "__main__":
    while True:
        ret, image = cap.read() # Read the frame
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # Convert to grayscale
        faces = face_cascade.detectMultiScale(gray, 1.1, 4) # Detect the faces
        
        for (x, y, w, h) in faces:
            roi_gray = gray[y: y+h, x: x+w]
            eyes_center = int(x + w/2)
            post_process_image = face_post_process(image, x, y, w, h, eyes_center)  # face post-process and visual
            
            cv2.imshow('OpenCV Face Detection', post_process_image) # Display image
        
        # Stop if escape key is pressed
        if cv2.waitKey(5) & 0xFF == ord('q'):
            break
    
    # Release the VideoCapture object
    cap.release()
    cv2.destroyAllWindows()
```

程序运行效果图如下所示:

![效果图](./images/output.png)

## 三，MediaPipe 趣味项目

略

## 参考资料
1. https://github.com/CharlesPikachu/pydrawing
2. https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0
3. https://google.github.io/mediapipe/solutions/face_detection.html
4. https://juejin.cn/post/7034325175021600782